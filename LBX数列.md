# Problem
![image](https://github.com/hellonk/hellonk.github.io/blob/master/problem_1143_6017969dce408ef57d4323fb2064c6c3.jpg)
# Solve
> ## 20分
> 我考试的时候想出来的方法就是一个很显然的dp
设f[i][j]为有i项，所有a[i]都比j小的时候数列的个数。
则f[i][j] = f[i-1][0]+f[i-1][1]+f[i-1][2]+......+f[i-1][j]
但是我们发现这个dp是O(n^3)的
> ## 20分的优化
可以优化，但是根本得不了高分。
f[i-1][0]+......+f[i-1][j]可以用一个前缀和，在计算f[i][j]的时候先计算一下f[i-1][j]的前缀和就好了。
> ## 100分算法
我们发现这就是一个不断计算前缀和的过程。
考虑打表找规律。
1 2 3 4 5 6
1 3 6 10 15 21
1 4 10 20 ......
我们把这个东西斜着看，第i行的第j个数等于c(i,i+j-1)。j+1写在下面，i写在上面。
但是我没有明白这是为什么...
