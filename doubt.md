# problem
![image](https://github.com/hellonk/hellonk.github.io/blob/master/problem_1162_92ee95a663e4db1741fc590a3f13c11f.jpg)
# solution
按照我的思考方式，先考虑一个点距离已知的n个点的距离最小是多少（距离是哈密顿距离）。
转化成数学题，设这n个点的坐标分别为 (x1, y1),(x2, y2), ......, (xn, yn)。
那么对于一个点来说，这个点的消耗就应该是 |a-x1|+|a-x2|+|a-x3|+......+|a-xn|+|b-y1|+|b-y2|+|b-y3|+......+|b-yn|
我们要让这个值尽量的小，对吧。所以我们就可以用一些数学方法就可以知道 a的值为 x1~xn的中位数的时候最优，b也同样。
我们可以计算出把所有n个小卖部都吸过来消耗的总内力最小是多少。吸走n-1个小卖部就是比吸走n个小卖部少吸走一个。
考虑不吸哪一个小卖部。我觉得是不吸走那个距离中位数最远的那个小卖部。但是错了。可能本来就是错的吧（但愿有人能帮我举出反例...）。
然后我们发现每一个可能成为吸其他小卖部的地方的地方只有可能是在小卖部的x轴和y轴的交点的地方，或者小卖部本身。
枚举所有交点。然后把每个点距离其他小卖部的距离计算出来。排序，然后求出来吸走最小的k个小卖部总小号是多少。就是求前缀和。
# 总结
> 我这道题在考试的时候做错了...下回的话呢，最好不要用自己证明不出来的东西。
我觉得正解的来源就是暴力算法。先想暴力算法，就是说我们枚举所有点，然后计算他们的代价，代价最优的即为答案。
然后发现代价最优的一定是小卖部的x轴和y轴的交点的地方或者小卖部本身。我们可以用上面的那一大堆绝对值得出这个结论。
