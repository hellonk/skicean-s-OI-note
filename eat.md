# Problem description
求用1 * 2的多米诺骨牌覆盖n * m 的情况总数
# Input format
输入一共一行，
第一行有两个整数，n和m。
# Output format
输出一共一行，
表示用1 * 2的多米诺骨牌覆盖n * m 的情况总数
# The scope of data
for 10% data, n<=1000000,m=2
for 30% data, n<=2^63-1,m=2
for 50% data, n<=50,m<=5
for 100% data, n<=2^63-1,m<=5
# solve
观察数据，发现最大的有2^63-1那么大，于是显然是一个 *logn* 的做法，就是矩阵乘法。先看前%40数据，n<=1000000和n<=2^63-1的数据，m都等于2。所以就可以用矩阵求斐波那契数列的第n项。然后第二个问题，就是在n<=50,m<=5的数据范围里面。怎么办呢？用状态压缩DP，f[i][j]表示前i行第i行的状态为j，j就是一个二进制数。转移方程嘛，f[i][j]只和f[i-1][k]有关系，转移一下即可。

不加矩阵快速幂的状压代码：
```cpp
#include <cstdio>
using namespace std;
const int N = 100, M = 5;
int n, m, f[N][1<<M];
bool judge (int state)
{
	int lianxu = 0, p = 0;
	bool a[20];
	for (int i = 1; i <= 10; ++i)
		a[i] = 0;
	while (state)
	{
		a[++p] = state & 1;
		state >>= 1;
	}
	for (int i = 1; i <= 10; ++i)
	{
		if (a[i] == 1)
			lianxu++;
		else
		{
			if ((lianxu & 1) == 1)
				return false;
		}
	}
	return true;
}
int main ()
{
	scanf ("%d %d", &n, &m);
	if (n < m)
		n ^= m ^= n ^= m;
	for (int i = 0; i < (1<<m); ++i)
		if (judge (i))
			f[1][i] = 1;
	for (int i = 1; i <= n-1; ++i)
		for (int j = 0; j < (1<<m); ++j)
		{
			int state = (1<<m)-1-j;
			for (int k = 0; k < (1<<m); ++k)
				if ((state|k) == k && judge (k-state))
					f[i+1][k] = (f[i+1][k] + f[i][j]) % 340340;
		}
	printf ("%d\n", f[n][(1<<m)-1]);
	return 0;
}
```

矩阵快速幂适用于n阶的齐次线性递推式，例如斐波那契数列，然后我们就需要把这个 n*(2^m-1)* 的dp转化成齐次线性递推式的转移。
我们发现第i次的总情况数只和第i-1次的总情况数有关，所以我们就可以滚动数组滚掉一维，只剩下一维 f[s],其中表示当前这一行的状态。
然后每回的情况数都是一个矩阵 (f[0], f[1], f[2], ......, f[(1<<m)-1])，第i回的矩阵*构造矩阵=i+1回的矩阵
我们就需要把那几个矩阵都初始化出来.......下面是初始化矩阵的代码

```cpp
#include <cstdio>
#include <map>
#include <set>
using namespace std;
const int N = 100, M = 5;
int n, m, f[N][1<<M];
bool judge (int state)
{
	int lianxu = 0, p = 0;
	bool a[20];
	for (int i = 1; i <= 10; ++i)
		a[i] = 0;
	while (state)
	{
		a[++p] = state & 1;
		state >>= 1;
	}
	for (int i = 1; i <= 10; ++i)
	{
		if (a[i] == 1)
			lianxu++;
		else
		{
			if ((lianxu & 1) == 1)
				return false;
		}
	}
	return true;
}
map<int,set<int> > nb;
bool matrix[N][N];
int main ()
{
	freopen ("code.out", "w", stdout);
	scanf ("%d %d", &n, &m);
	if (n < m)
		n ^= m ^= n ^= m;
	for (int i = 0; i < (1<<m); ++i)
		if (judge (i))
			f[1][i] = 1;
	for (int i = 1; i < n; ++i)
		for (int j = 0; j < (1<<m); ++j)
		{
			int state = (1<<m)-1-j;
			for (int k = 0; k < (1<<m); ++k)
				if ((state|k) == k && judge (k-state))
				{
					f[i+1][k] = (f[i+1][k] + f[i][j]) % 340340;
					nb[k].insert (j);
					printf ("i=%d j=%d i+1=%d k=%d\n", i, j, i+1, k);
				}
		}
//	printf ("%d\n", f[n][(1<<m)-1]);
	for (map<int,set<int> >::iterator it = nb.begin (); it != nb.end (); ++it)
		for (set<int>::iterator itit = it->second.begin (); itit != it->second.end (); ++itit)
			matrix[(*itit)][(it->first)] = 1;
	printf ("{");
	for (int i = 0; i < (1<<m); ++i)
	{
		printf ("{");
		for (int j = 0; j < (1<<m); ++j)
		{
			if (j==(1<<m)-1)
				printf ("%d", matrix[i][j]);
			else
				printf ("%d,", matrix[i][j]);
		}
		printf ("}");
		if (i==(1<<m)-1)
			break;
		printf ("\n");
	}
	printf ("}");
	return 0;
}
```
现在我们只需要写矩阵快速幂就可以了
```cpp
#include <cstdio>
#include <cstring>
#define int long long
using namespace std;
const int N = 60, M = 60, Mod = 340340;
bool f2[4][4] = {{0,0,0,1},{0,0,1,0},{0,1,0,0},{1,0,0,1}};
bool f3[8][8] = {{0,0,0,0,0,0,0,1},{0,0,0,0,0,0,1,0},{0,0,0,0,0,1,0,0},{0,0,0,0,1,0,0,1},{0,0,0,1,0,0,0,0},{0,0,1,0,0,0,0,0},{0,1,0,0,0,0,0,1},{1,0,0,1,0,0,1,0}};
bool f4[16][16] = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1},{0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1},{0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1},{0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0},{0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0},{1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1}};
bool f5[32][32] = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},{0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},{0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0},{0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0},{0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1},{1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0}};
struct Matrix
{
	int row, column, matrix[60][60];
	void init ()
	{
		memset (matrix, 0, sizeof (matrix));
	}
	Matrix operator * (const Matrix &x)
	{
		Matrix ans;
		ans.init ();
		ans.row = row;
		ans.column = x.column;
		for (int i = 0; i < ans.row; ++i)
			for (int j = 0; j < ans.column; ++j)
				for (int k = 0; k < column; ++k)
					ans.matrix[i][j] = (ans.matrix[i][j] + (long long) (matrix[i][k] % Mod)*(x.matrix[k][j] % Mod)) % Mod;
		return ans;
	}
	void makeE (int sze)
	{
		row = sze;
		column = sze;
		for (int i = 0; i < sze; ++i)
			matrix[i][i] = 1;
	}
};
Matrix fastPow (Matrix x, int zs)
{
	Matrix ret;
	ret.makeE (x.column);
	while (zs)
	{
		if (zs&1)
			ret = ret*x;
		x = x*x;
		zs >>= 1;
	}
	return ret;
}
bool judge (int state)
{
	int lianxu = 0, p = 0;
	bool a[20];
	for (int i = 1; i <= 10; ++i)
		a[i] = 0;
	while (state)
	{
		a[++p] = state & 1;
		state >>= 1;
	}
	for (int i = 1; i <= 10; ++i)
	{
		if (a[i] == 1)
			lianxu++;
		else
		{
			if ((lianxu & 1) == 1)
				return false;
		}
	}
	return true;
}
signed main ()
{
	int n, m;
	scanf ("%lld %lld", &n, &m);
	Matrix ans;
	ans.row = 1;
	ans.column = (1<<m);
	for (int i = 0; i < (1<<m); ++i)
		if (judge (i))
			ans.matrix[0][i] = 1;
	Matrix Mat;
	if (m == 2)
	{
		Mat.row = 4;
		Mat.column = 4;
		for (int i = 0; i < 4; ++i)
			for (int j = 0; j < 4; ++j)
				Mat.matrix[i][j] = f2[i][j];
	}
	else if (m == 3)
	{
		Mat.row = 8;
		Mat.column = 8;
		for (int i = 0; i < 8; ++i)
			for (int j = 0; j < 8; ++j)
				Mat.matrix[i][j] = f3[i][j];
	}
	else if (m == 4)
	{
		Mat.row = 16;
		Mat.column = 16;
		for (int i = 0; i < 16; ++i)
			for (int j = 0; j < 16; ++j)
				Mat.matrix[i][j] = f4[i][j];
	}
	else if (m == 5)
	{
		Mat.row = 32;
		Mat.column = 32;
		for (int i = 0; i < 32; ++i)
			for (int j = 0; j < 32; ++j)
				Mat.matrix[i][j] = f5[i][j];
	}
	Matrix pow = fastPow (Mat, n-1);
	ans = ans*pow;
	printf("%d\n", ans.matrix[0][(1<<m)-1]);
	return 0;
}
```
当然，这道题还有一个很重要的细节，就是要开 **long long** ! 考试的时候因为这个我失去了20分......
# The key of this problem
> 如何在考试的时候做出这道题？
> 当我们发现一道题可以用一个复杂的数学公式完成时，基本就是要用到矩阵快速幂
> 另外一个判断方法就是数据范围让你在 log n的复杂度内完成时就用矩阵快速幂
